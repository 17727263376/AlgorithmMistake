<font size = "4">

### 题目描述：

HDU 2006'10 ACM contest的颁奖晚会隆重开始了！ 
为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的： 

首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中； 
然后，待所有字条加入完毕，每人从箱中取一个字条； 
最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！” 

大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！ 

我的神、上帝以及老天爷呀，怎么会这样呢？ 

不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？ 

不会算？难道你也想以悲剧结尾？！ 

### Input
输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1<n<=20),表示参加抽奖的人数。 

### Output
对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小数(四舍五入)，具体格式请参照sample output。 

### 思路一：next_permutation()全排列
非常的暴力暴力，最后也果不其然的超时了。但是对我之后找规律起到了很大的辅助作用。

### 思路二：递推
通过上一种暴力情况，我把所有的满足情况输出找规律，最后找到了递推规律。
![image](http://wx1.sinaimg.cn/large/0060lm7Tly1g38xxjtg1hj309l0e9jrb.jpg)

首先我们来看，对于人数为n的输出结果很明显分为(n-1)大块部分，以第一列为例，第一列除了不能放本身0之外，其余的1~n-1都可以放，所以分为(n-1)块

在仔细看，我们会发现每一块的数目都是一样多的，就比如n等于4时，第一块当第一列放1时有3种情况。这就进一步发现了规律。那么最后满足情况的数目一定等于块数*每一块所含的数目。

块数可以十分简单的的发现他等于n-1块

那么每一块所含数目呢。我们继续观察，发现如下规律

| n              | 1 | 2 | 3 | 4 | 5  | 6   |
|----------------|--:|---|---|---|----|-----|
| 满足条件数     | 0 | 1 | 2 | 9 | 44 | 265 |
| 每一块包含数目 | 0 | 1 | 1 | 3 | 11 | 53  |

我们发现n的每一块包含数目等于(n-1)和(n-2)满足条件数相加。这样一来题目的规律就十分清晰了。

接下来是另一问：总数，总数最高达20的阶乘，所以硬算阶乘是不可取的。这个时候就需要总结出递推的总公式了：

> key[i] = (key[i-1]*num[i])/(i*num[i-1]);

也就是他了，让我们来看全部的代码吧。

```
#include<iostream>
using namespace std;
int main ()
{
	double num[25];
	int i;
	double key[25];
	num[1] = 0; num[2] = 1;
	for(i = 3; i<=20; i++){
		num[i] = (num[i-1]+num[i-2])*(i-1);
	}
	key[1] = 0; key[2] = 50;
	for(i = 3; i<=20; i++){
		key[i] = (key[i-1]*num[i])/(i*num[i-1]);
		/*
		下面这几条是在保留两位小数点的基础上四舍五入的方法
		*/
		key[i] *= 100;
		key[i] += 0.5;
		key[i] = (int)key[i];
		key[i] /= 100;
	}
	int C, n;
	cin>>C;
	while(C--){
		cin>>n;
		printf("%.2f%%\n", key[n]);
	}
	return 0;
}
```
</font>