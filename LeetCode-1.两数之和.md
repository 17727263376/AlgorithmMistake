**题目描述：**

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**例如：**
- - -
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
- - -
**思路一：**

暴力法：对于每一个数字，枚举其他所有坐标，直到找到正确坐标。这样的时间复杂度为n^2;

**思路二：**

使用map记录一个数字是否存在：这样的方法可以将时间复杂度降低为n，因为每遍历一个元素，就判断target-i是否存在。
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> m;
        for(int i = 0; i<nums.size(); ++i){
        	if(m.count(target-nums[i])){
                return {i, m[target-nums[i]]};
            }
            m[nums[i]] = i;
		}
        return {};
    }
};
```
map和unordered_map的区别：

- - -
map:低层使用红黑树实现，满足二叉搜索。它是有序的。

unordered_map：低层使用的是散列表，对于查找的时间复杂度接近1，所以它更适合查找运算比较多的情况。
- - -
**体会：**

这是刷的第一道LeetCode的题目，属于简单题，但是对于我来说，这道题一开始是没有思路的。我的想法就是n^2平方的复杂度，完全没有想到使用一个map存储一个数是否存在。
这里也反应了我对于c++封装好的库使用很不熟练，如果经常熟悉这些库，我的思路就会拓宽。所以还是多刷题吧！