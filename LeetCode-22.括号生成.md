**题目描述：**

给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。

**例如：**

给出 n = 3，生成结果为：

[

  "((()))",
  
  "(()())",
  
  "(())()",
  
  "()(())",
  
  "()()()"
  
]

**错误思路一：**

首先我想到的是用递归，求n的组合情况可以等于(n-1)+"()"或者"()"+(n-1)或者'('+(n-1)+')'这种情况，在只需要判断是否重复即可。

结果在n等于4的情况就出线了有漏的情况。所以失败了

**正确思路：**

回溯法：虽然我一开始也想到了使用回溯法，但是我一直想不通回溯的临界的条件。
```
class Solution {
public:
    void m(string c, vector<string> &result, int n, int l, int r){
    //l代表'('的数量，r代表')'的数量
        if(r == n){
            result.push_back(c);
            //当右括号等于n的时候，代表已经完成了一种组合。
        }
        if(l < n){
            m(c+'(', result, n, l+1, r);
            //我们的原则是能加左括号就加左括号，所以只要有我们就加
        }
        if(r < l){
            m(c+')', result, n, l, r+1);
            //当左括号用完的时候，我们就加右括号，但是只有左括号的数目多于右括号的时候，才可以加
        }
    }
    vector<string> generateParenthesis(int n) {
        vector<string> result;
        m("", result, n, 0, 0);
        return result;
    }
};
```