**题目描述：**

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

**例如1：**
- - -
输入: "abcabcbb"

输出: 3 

解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

**例如2：**
- - -
输入: "bbbbb"

输出: 1

解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

**例如3：**
- - -
输入: "pwwkew"

输出: 3

解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
- - -

**思路一：**

暴力法：枚举所有的字串并且判断是否为无重复的字串，然后记录最大值。这种方法太暴力，时间复杂度为n^3

**思路二：**

滑动窗口法：维护一个区间，在这个区间内的元素，一定是满足题意的，并且使用一个MAX值记录最大值，使用map判断是否存在字符，并且map需要记录出现的字符的最新地址
```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int len = s.length();
        if(len == 0)    return 0;
        unordered_map<char,int> m;
        int l = 0, max = 0;
        for(int i = 0; i<len; ++i){
            l = l>m[s[i]]?l:m[s[i]];
            m[s[i]] = i + 1;
            max = max>(i-l+1)?max:(i-l+1);
        }
        return max;
    }
};
```
**体会：**

这道题我首先想到的方法是用递归，将一个字符串分为两段，求出两段的最大字串后，在从分割点开始算字串，然后判断是否比两边的都大，这个方法是根据算法竞赛入门里面求最大递增字串得来的。但是这样是错的。因为原来的字符串是无序的。例如"bpfbhmipx"这个情况就错了。最后还是看网上别人写的代码，写学会了滑动窗口这个方法。

